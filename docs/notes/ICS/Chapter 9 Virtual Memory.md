## 9.1 物理和虚拟寻址
计算机系统的主存被组织成一个由 $M$ 个连续的字节大小的单元组成的数组. 每字节都有一个唯一的物理地址 (PA). 第一个字节的地址为 0, 下一个为 1, 依此类推.

CPU 访问内存的最自然的方式就是使用物理地址. 我们把这种方式称为物理寻址. 
下图的指令读取从物理地址 4 处开始的 4 字节字. CPU 执行这条加载指令时, 会生成一个有效物理地址, 通过内存总线把它传递给主存 (一次传递数据总线宽度的字). 主存取出从物理地址 4 处开始的 4 字节字, 并将它返回给 CPU, CPU 将它存放在寄存器里.
![](Pasted%20image%2020251126152346.png)

现代处理器使用的是一种称为虚拟寻址的寻址形式.
![](Pasted%20image%2020251126152835.png)
CPU 通过生成一个虚拟地址来访问主存, 这个虚拟地址在被送到内存之前先转换成合适的物理地址, 将虚拟地址转换为物理地址的任务叫做地址翻译. CPU 芯片上叫做内存管理单元(MMU) 的专用硬件, 利用存放在主存中的查询表来动态翻译虚拟地址, 该表的内容由操作系统管理.

物理寻址存在的问题:
- 如何让所有东西都容纳? 我们实际允许程序访问的地址空间可能有 2\^64 字节, 但是事实上一般的内存只有 16GB 或 32GB. - 使用虚拟内存!
- 不同的进程使用同一片物理地址空间, 万一别的进程把数据存入了我的内存怎么办? - 使用虚拟内存!
- 程序如何知道使用哪块内存? - 使用虚拟内存! 为内存提供了统一的视图, 所有内存都可以从 0x0000...0 开始.

## 9.2 地址空间
![](Pasted%20image%2020251126154622.png)

## 9.3 虚拟内存作为缓存的工具
从概念上将, 虚拟内存被组织为一个存放在磁盘上的 $N$ 个连续的字节大小的单元组成的数据. 每字节都有一个唯一的虚拟地址, 作为到数组的索引. 

前面我们说到, 内存不足以容纳 $2^{64}$ 这么多字节的数据, 因此一部分数据是存储在更低级的存储结构--磁盘中的. 而虚拟内存很好地充当了这两级存储结构之间缓存的效果.

和其他缓存一样, 磁盘上的数据被分割成块, 作为磁盘和主存之间的传输单元. VM 系统将虚拟内存分割为称为 **虚拟页** 的大小固定的块来处理这个问题.  每个虚拟页的大小为 $P=2^p$ 字节. 类似地, 物理内存被分割位物理页 (PP), 大小也为 $P$ 字节.

在任意时刻, 虚拟页的情况有三种:
- 未分配的: VM 系统还未分配或创建的页, 未分配的块没有任何数据与它们相关联, 因此不占用任何磁盘空间.
- 缓存的: 当前已缓存在物理内存的已分配页
- 未缓存的: 未缓存在物理内存中的已分配页

![](Pasted%20image%2020251126160346.png)

### 9.3.1 DRAM 缓存的组织结构
由于 DRAM 跟磁盘传输数据的速度极慢, 因此虚拟页往往设置的很大, 减少 I/O 操作延迟. 由于大的不命中处罚, DRAM 缓存是全相联的, 即任何虚拟页都可以放在任何物理页中. 不命中时的替换策略也很重要, DRAM 缓存使用了更复杂精密的替换算法. 因为对磁盘的访问时间很长, DRAM 缓存总是使用写回, 而不是直写.

### 9.3.2 页表
同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM中，替换这个牺牲页。

这些功能是由软硬件联合提供的，包括操作系统软件、MMU(内存管理单元)中的地址翻译硬件和一个存放在物理内存中叫做页表(page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与DRAM之间来回传送页。

页表就是一个页表条目(Page Table Entry, PTE) 的数组. 虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE.

我们假设每个 PTE 都由一个有效位和一个 $n$ 位地址字段组成. 有效位表明该虚拟页是否被缓存在 DRAM 中. 如果设置了有效位, 那么地址字段就表示 DRAM 中相应物理页的起始位置. 如果没有设置有效位, 那么空地址表示该虚拟页还未分配, 否则地址指向该虚拟页在磁盘上的起始位置.

![](Pasted%20image%2020251126161453.png)


这个练习可以帮助你更好理解页表和虚拟页的关系.
![](Pasted%20image%2020251126161652.png)
![](Pasted%20image%2020251126161638.png)

>[!question]
>如果虚拟地址大小有 2\^64, 页大小是 4K, 需要多少 PTE? 内存放得下吗?

### 9.3.3 页命中
当 CPU 想要读包含在 VP2 中的虚拟内存中的一个字时, 我们发现 VP2 被缓存在 DRAM 中. 使用在 9.6 节将介绍的一种技术, 地址翻译硬件将虚拟地址作为一个索引来定位 PTE 2, 并从内存中读取它.
![](Pasted%20image%2020251126162513.png)

### 9.3.4 缺页
DRAM 缓存不命中称为 **缺页**. CPU 引用了 VP3 中的一个字, VP3 并未缓存在 DRAM 中. 地址翻译硬件从内存中读取 PTE 3, 从有效位推断出 VP3 未被缓存, 并且触发一个缺页异常. 它调用内核中的缺页异常处理程序, 该程序会选择一个牺牲页, 这里是 VP4. 如果 VP4 被修改了, 内核会将它复制回磁盘. 无论哪种情况, 内核都会修改 VP4 的页表条目, 反映出它不再缓存在 DRAM 中的事实.

接下来, 内核就会复制 VP3 到内存中对应位置, 更新 PTE 3.
![](Pasted%20image%2020251126162826.png)
![](Pasted%20image%2020251126162840.png)

### 9.3.5 分配页面
![](Pasted%20image%2020251126162957.png)


#### 触发新分配页的常见情况

|**编程操作**|**虚拟内存机制**|**结果与解释**|
|---|---|---|
|**首次访问堆内存**|**按需分页 (Demand Paging)**|当程序通过 `malloc` 或 C++ 的 `new` 请求内存时，操作系统通常只在虚拟地址空间中预留地址。只有当程序**首次写入或访问**这块内存时，才会触发缺页中断，内核随后分配一个**全新的、零填充的物理页**，并更新页表映射。|
|**栈增长**|**栈扩展 (Stack Growth)**|当函数调用导致栈溢出当前映射的内存范围时，CPU 会访问一个**未映射**的虚拟地址。操作系统捕获异常，并为栈分配一个新的物理页，使其能够继续执行。|
|**写时复制（COW）**|**内存隔离**|在 `fork()` 之后，父子进程共享同一块物理内存（只读）。当**任一进程首次尝试写入**这块共享内存时，会触发写保护故障，操作系统必须分配一个新的物理页，并将原始数据复制进去，确保进程隔离。|
|**文件映射（mmap）**|**文件映射 I/O**|当程序通过 `mmap` 将一个文件映射到虚拟地址空间后，只有当程序**首次访问**该虚拟地址时，才会从磁盘上的文件中读取相应的数据，并分配一个物理页来存储这些数据。|

### 9.3.6 Locality to the Rescue Again!
![](Pasted%20image%2020251126163327.png)
注意, 虚拟内存没有冲突不命中(全相联)

## 9.4 虚拟内存作为内存管理工具
操作系统为 **每个进程** 提供了一个独立的页表, 因而也就是一个独立的虚拟地址空间. 
注意, 不同进程中的虚拟页可能映射到同一个物理页面.
![](Pasted%20image%2020251126163516.png)

- 简化链接: 独立的地址空间允许不同进程的内存使用相同的基本格式, 而不关心它们实际存放在物理内存的何处. 例如, 对于 64位地址空间, 代码段总是从虚拟地址 0x400000 开始.
- 简化加载: Linux 在程序加载时, 只设置虚拟地址映射, 将它们指向磁盘地址, 并标记为未缓存, 而不进行实际数据复制. 只有当 CPU 需要它们的时候, 才去触发缺页中断交换进内存. 
  将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法(也就是上面所说的将程序的代码和数据段和一段虚拟页关联起来)称为**内存映射**. Linux 提供一个称为 mmap 的系统调用, 允许应用程序自己做内存映射, 这会在 9.8 节讨论.
- 简化共享: 一般而言, 每个进程都有自己私有的代码, 数据, 堆栈等区域. 这时候页表会将相应的虚拟页映射到不同的物理页. 然而在一些情况中, 比如共享库函数, 需要调用相同的代码, 这时候就会将不同进程中适当的虚拟页面映射到相同的物理页面.
- 简化内存分配: 当一个运行在用户进程中的程序要求额外的堆空间(例如调用 malloc), 操作系统会分配一个适当数字个连续的虚拟内存页面, 并将它们映射到物理内存中任意位置的 k 个任意的物理页面

## 9.5 虚拟内存作为内存保护的工具
通过在 PTE 上添加一些额外的许可位来控制对虚拟页面内容的访问十分简单.
![](Pasted%20image%2020251126165600.png)

- SUP 位表示进程是否必须运行在内核(超级用户)模式下才能访问该页. 允许在内核模式下的进程可以访问任何页面.
- READ和WRITE 位控制对页面的读写访问.
- 一旦一条指令违反了许可条件, CPU 就会触发一个一般保护故障, 将控制传递给内核中的异常处理程序. Linux shell 一般将这种异常报告为"段错误(segmentation fault)"

## 9.6 地址翻译
